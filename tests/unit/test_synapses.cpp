#include "../gtest.h"
#include "../test_util.hpp"

#include <cell.hpp>
#include <backends/multicore/fvm.hpp>

#include <mechanisms/multicore/expsyn_cpu.hpp>
#include <mechanisms/multicore/exp2syn_cpu.hpp>

// compares results with those generated by nrn/ball_and_stick.py
TEST(synapses, add_to_cell)
{
    using namespace arb;

    arb::cell cell;

    // Soma with diameter 12.6157 um and HH channel
    auto soma = cell.add_soma(12.6157/2.0);
    soma->add_mechanism("hh");

    cell.add_synapse({0, 0.1}, "expsyn");
    cell.add_synapse({1, 0.2}, "exp2syn");
    cell.add_synapse({0, 0.3}, "expsyn");

    EXPECT_EQ(3u, cell.synapses().size());
    const auto& syns = cell.synapses();

    EXPECT_EQ(syns[0].location.segment, 0u);
    EXPECT_EQ(syns[0].location.position, 0.1);
    EXPECT_EQ(syns[0].mechanism.name(), "expsyn");

    EXPECT_EQ(syns[1].location.segment, 1u);
    EXPECT_EQ(syns[1].location.position, 0.2);
    EXPECT_EQ(syns[1].mechanism.name(), "exp2syn");

    EXPECT_EQ(syns[2].location.segment, 0u);
    EXPECT_EQ(syns[2].location.position, 0.3);
    EXPECT_EQ(syns[2].mechanism.name(), "expsyn");
}

TEST(synapses, expsyn_basic_state)
{
    using namespace arb;
    using memory::make_const_view;
    using size_type = multicore::backend::size_type;
    using value_type = multicore::backend::value_type;

    using synapse_type = multicore::mechanism_expsyn<multicore::backend>;
    int num_syn = 4;
    int num_comp = 4;
    int num_cell = 1;

    synapse_type::iarray cell_index(num_comp, 0);
    synapse_type::array time(num_cell, 0);
    synapse_type::array time_to(num_cell, 0.1);
    synapse_type::array dt(num_comp, 0.1);

    std::vector<size_type> node_index(num_syn, 0);
    std::vector<value_type> weights(num_syn, 1.0);
    synapse_type::array voltage(num_comp, -65.0);
    synapse_type::array current(num_comp,   1.0);

    auto mech = make_mechanism<synapse_type>(0, cell_index, time, time_to, dt, voltage, current, make_const_view(weights), make_const_view(node_index));
    auto ptr = dynamic_cast<synapse_type*>(mech.get());

    auto n = ptr->size();
    using view = synapse_type::view;

    // parameters initialized to default values
    for(auto e : view(ptr->e, n)) {
        EXPECT_EQ(e, 0.);
    }
    for(auto tau : view(ptr->tau, n)) {
        EXPECT_EQ(tau, 2.0);
    }

    // current and voltage vectors correctly hooked up
    for(auto v : view(ptr->vec_v_, n)) {
        EXPECT_EQ(v, -65.);
    }
    for(auto i : view(ptr->vec_i_, n)) {
        EXPECT_EQ(i, 1.0);
    }

    // should be initialized to NaN
    for(auto g : view(ptr->g, n)) {
        EXPECT_NE(g, g);
    }

    // initialize state then check g has been set to zero
    ptr->nrn_init();
    for(auto g : view(ptr->g, n)) {
        EXPECT_EQ(g, 0.);
    }

    // call net_receive on two of the synapses
    ptr->net_receive(1, 3.14);
    ptr->net_receive(3, 1.04);
    EXPECT_EQ(ptr->g[1], 3.14);
    EXPECT_EQ(ptr->g[3], 1.04);
}

TEST(synapses, exp2syn_basic_state)
{
    using namespace arb;
    using memory::make_const_view;
    using size_type = multicore::backend::size_type;
    using value_type = multicore::backend::value_type;

    using synapse_type = multicore::mechanism_exp2syn<multicore::backend>;
    int num_syn = 4;
    int num_comp = 4;
    int num_cell = 1;

    synapse_type::iarray cell_index(num_comp, 0);
    synapse_type::array time(num_cell, 0);
    synapse_type::array time_to(num_cell, 0.1);
    synapse_type::array dt(num_comp, 0.1);

    std::vector<size_type> node_index(num_syn, 0);
    std::vector<value_type> weights(num_syn, 1.0);
    synapse_type::array voltage(num_comp, -65.0);
    synapse_type::array current(num_comp,   1.0);

    auto mech = make_mechanism<synapse_type>(0, cell_index, time, time_to, dt, voltage, current, make_const_view(weights), make_const_view(node_index));
    auto ptr = dynamic_cast<synapse_type*>(mech.get());

    auto n = ptr->size();
    using view = synapse_type::view;

    // parameters initialized to default values
    for(auto e : view(ptr->e, n)) {
        EXPECT_EQ(e, 0.);
    }
    for(auto tau1: view(ptr->tau1, n)) {
        EXPECT_EQ(tau1, 0.5);
    }
    for(auto tau2: view(ptr->tau2, n)) {
        EXPECT_EQ(tau2, 2.0);
    }

    // should be initialized to NaN
    for(auto factor: view(ptr->factor, n)) {
        EXPECT_NE(factor, factor);
    }

    // initialize state then check factor has sane (positive) value
    // and A and B are zero
    ptr->nrn_init();
    for(auto factor: view(ptr->factor, n)) {
        EXPECT_GT(factor, 0.);
    }
    for(auto A: view(ptr->A, n)) {
        EXPECT_EQ(A, 0.);
    }
    for(auto B: view(ptr->B, n)) {
        EXPECT_EQ(B, 0.);
    }

    // call net_receive on two of the synapses
    ptr->net_receive(1, 3.14);
    ptr->net_receive(3, 1.04);

    EXPECT_NEAR(ptr->A[1], ptr->factor[1]*3.14, 1e-6);
    EXPECT_NEAR(ptr->B[3], ptr->factor[3]*1.04, 1e-6);
}
